#lang racket

(require rackunit)

(provide (all-defined-out))

;; QF_UF: Quantifier free theory of uninterpreted functions with equality
;; UNSORTED FOL
;; Grammar of formulae
;; φ ::= φ bconn φ | ¬ φ | t = t | t ≠ t
;; bconn ::= ∨ | ∧ | ⇒
;; t ::= x | f(t, ...)

;; Each function symbol has an arity that must be declared.
;; (declare-fun f 3) means that f must take 3 arguments.

;; A Term is a Var or an App
(struct Var (x) #:transparent) ;; x : Symbol
(struct App (f args) #:transparent) ;; f : Symbol, args : (Listof Term)

;; l and r are Terms.
(struct Equality (l r) #:transparent)
;; l and r are equalities of the form (Equality (App 'Apply (List Var Var)) Var)
(struct EQpair (l r) #:transparent)

(struct EUF-state (equalities ;; DimacsVar ↦ Equality
                   backjump-table ;; Satisfaction-level ↦ DimacsVar
                   satisfaction-level ;; Natural that gets bumped each T-Satisfy.
                   pending ;; Listof (U (Equality Var Var) EQpair)
                   representative ;; Var ↦ Var
                   classes ;; Var ↦ Listof Var
                   uses ;; Var ↦ Listof (Equality (App 'Apply (List Var Var)) Var)
                   lookup ;; (Pair Var Var) ↦ Option (Equality (App 'Apply (List Var Var)) Var)
                   ) #:transparent)

(define (merge t-state s=t)
  (match s=t
    [(Equality (Var a) (Var b))
     (propagate (add-to-pending t-state s=t))]
    [(Equality (App f (list (Var a₁) (Var a₂))) va)
     (let* ((a₁′ (get-representative t-state a₁))
            (a₂′ (get-representative t-state a₂))
            (res (dict-ref (EUF-state-lookup t-state) (cons a₁′ a₂′))))
       (if (Equality? res)
           (propagate (add-to-pending t-state (cons s=t res)))
           (let* ((t-state (set-lookup t-state (cons a₁′ a₂′) s=t))
                  (t-state (add-to-uses t-state a₁′ s=t))
                  (t-state (add-to-uses t-state a₂′ s=t)))
             t-state)))]))

(define (propagate t-state)
  (let loop ((pending (EUF-state-pending t-state)))
    (unless (empty? pending)
            (let*-values ([(a b)
                           (match (car pending)
                             [(Equality a b)
                              (values a b)]
                             [(EQpair (Equality (App 'Apply (list a₁ a₂)) a)
                                      (Equality (App 'Apply (list b₁ b₂)) b))
                              (values a b)]
                             [other (error "propagate: Internal invariant violated ~a" other)])]
                          [(a′ b′) (values (get-representative t-state a)
                                           (get-representative t-state b))])
              (if (or (eqv? a′ b′)
                      (> (length (dict-ref (EUF-state-classes t-state) a′))
                         (length (dict-ref (EUF-state-classes t-state) b′))))
                  (loop (cdr pending))
                  
                  (begin (set-lookup t-state (cons 
                  ...)))))
               

(define (add-to-pending t-state equality)
  ...)

(define (set-lookup t-state representative-pair equality)
  ...)

(define (add-to-uses t-state representative equality)
  ...)

(define (get-representative t-state var)
  ...)
